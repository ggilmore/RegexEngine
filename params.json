{"name":"RegexEngine","tagline":"","body":"# RegexEngine\r\n\r\n##Intro: \r\nThis is a simple regex engine written in Scala that I made following [this article](http://perl.plover.com/Regex/article.html). \r\n\r\n##Supported Grammar: \r\n([borrowed and modified from Matt Might](http://matt.might.net/articles/parsing-regex-with-recursive-descent/))\r\n\r\n\r\n     <regex> ::= <term> '|' <regex>\r\n             ::=  <term>\r\n     \r\n     <term>  ::= <factor>+\r\n     \r\n     <factor> ::= <factor> ('*'| '?'|'+')?\r\n              ::= <base> ('*'| '?'|'+')?\r\n     \r\n     <base>  ::= <char>\r\n             ::=  '\\' <char>\r\n             ::= '(' <regex> ')'\r\n\r\n##Basic Usage: \r\nThe `RegexParser` class is used to parse a string that represents a regex. Create a new `RegexParser` instance and use its `parse()`\r\nmethod in order to create a [Machine](https://en.wikipedia.org/wiki/Nondeterministic_finite_automaton) instance that represents that\r\nregex. \r\n\r\nThe `MachineRunner` object has a method called `testInput` that takes a `Machine` and some `inputString` and returns `true` if the\r\n`inputString` matches the regex that the `Machine` represents, and false otherwise. \r\n\r\nThe `Machine` companion object also has a helper function, called `toDOTFileFormat` that takes a `Machine`, and returns a string representation \r\nof that machine using the [DOT graph description language](https://en.wikipedia.org/wiki/DOT_%28graph_description_language%29).\r\nThis graph has nodes as states, unlabeled edges representing transitions that aren't contingent on any character, and labeled edges \r\nrepresenting transitions that are contingent on the character that the edge is labeled with. \r\n  \r\nExample of a graph generated from `toDOTFileFormat`'s output from the regex `((ab|b?)*w)`: ![example](http://i.imgur.com/KolYNn3.png)\r\n\r\n#TODO:\r\n-test cases?\r\n-work on visualization of state machine \r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}